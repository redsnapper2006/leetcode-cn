use std::collections::HashMap;
use std::collections::VecDeque;
impl Solution {
  pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
    let mut buf: Vec<i32> = vec![0; graph.len()];
    let mut initial = initial;
    initial.sort();
    let n = graph.len();

    // dfs
    let mut q: VecDeque<usize> = VecDeque::new();
    let mut color: i32 = 0;
    (0..n).for_each(|node| {
      if buf[node] > 0 {
        return;
      }

      color += 1;
      buf[node] = color;
      q.push_back(node);
      while q.len() > 0 {
        let next = q.pop_front().unwrap();
        buf[next] = color;
        (0..n).for_each(|idx| {
          if graph[next][idx] == 1 && buf[idx] == 0 {
            q.push_back(idx);
          }
        });
      }
    });

    let mut color_count: HashMap<i32, i32> = HashMap::new();
    (0..n).for_each(|node| {
      let color = buf[node];
      let count = color_count.entry(color).or_insert(0);
      *count += 1;
    });

    let mut visited: HashMap<i32, i32> = HashMap::new();
    initial.iter().for_each(|&node| {
      *visited.entry(buf[node as usize]).or_insert(0) += 1;
    });

    let mut ret: i32 = std::i32::MAX;
    let mut max: i32 = -1;
    initial.iter().for_each(|&node| {
      let color = buf[node as usize];
      let count = *color_count.get(&color).unwrap();
      if *visited.get(&color).unwrap() > 1 {
        return;
      }
      if count > max {
        max = count;
        ret = node;
      } else if count == max && node < ret {
        ret = node;
      }
    });
    if ret == std::i32::MAX {
      initial[0]
    } else {
      ret
    }
  }
}
