use std::collections::HashMap;
use std::collections::HashSet;
use std::collections::VecDeque;
impl Solution {
  pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
    let mut buf: Vec<i32> = vec![0; graph.len()];
    let n = graph.len();

    // dfs
    let mut q: VecDeque<usize> = VecDeque::new();
    let mut color: i32 = 0;
    (0..n).for_each(|node| {
      if buf[node] > 0 {
        return;
      }

      color += 1;
      buf[node] = color;
      q.push_back(node);
      while q.len() > 0 {
        let next = q.pop_front().unwrap();
        buf[next] = color;
        (0..n).for_each(|idx| {
          if graph[next][idx] == 1 && buf[idx] == 0 {
            q.push_back(idx);
          }
        });
      }
    });

    let mut color_count: HashMap<i32, i32> = HashMap::new();
    (0..n).for_each(|node| {
      let color = buf[node];
      let count = color_count.entry(color).or_insert(0);
      *count += 1;
    });

    let mut idx: usize = 0;
    let mut ret: i32 = graph.len() as i32;
    let mut min: i32 = graph.len() as i32;

    while idx < initial.len() {
      let mut sum: i32 = 0;
      let node = initial[idx] as usize;
      let color = buf[node];

      let mut idx2: usize = 0;
      let mut visited: HashSet<usize> = HashSet::new();
      let mut color_visited: HashSet<i32> = HashSet::new();
      while idx2 < initial.len() {
        if idx == idx2 {
          idx2 += 1;
          continue;
        }

        let node2 = initial[idx2] as usize;
        if buf[node2] != color {
          if !color_visited.contains(&buf[node2]) {
            sum += color_count.get(&buf[node2]).unwrap();
            color_visited.insert(buf[node2]);
          }
          idx2 += 1;
          continue;
        }

        if visited.contains(&node2) {
          idx2 += 1;
          continue;
        }

        let mut q2: VecDeque<usize> = VecDeque::new();
        q2.push_back(node2);
        visited.insert(node2);
        while q2.len() > 0 {
          let next = q2.pop_front().unwrap();
          sum += 1;

          (0..n).for_each(|node3| {
            if node3 != node && graph[next][node3] == 1 && !visited.contains(&node3) {
              q2.push_back(node3);
              visited.insert(node3);
            }
          });
        }
        idx2 += 1;
      }

      if sum < min {
        min = sum;
        ret = initial[idx];
      } else if sum == min && initial[idx] < ret {
        ret = initial[idx];
      }

      idx += 1;
    }

    ret
  }
}
